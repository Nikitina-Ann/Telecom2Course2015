#SMTP-клиент
##Индивидуальное задание

Разработать приложение для операционных систем семейства Windows
или Linux, обеспечивающее функции клиента протокола SMTP.  
Основные возможности. Приложение должно реализовывать следующие функции: 
 
1. Создание нового письма, включающего такие поля, как From (от-
правитель), To (получатель), Subject (тема), Carbon copy (дополни-
тельные адресаты), Blind copy (дополнительные скрытые адресаты),
Body (текст)
2. Формирование всех необходимых заголовков письма, с тем, чтобы
приёмная сторона не рассматривала данное письмо как спам.
3. Подключение к указанному SMTP-серверу и отсылка созданного
письма
4. Подробное протоколирование соединения клиента с сервером   

Поддерживаемые команды. Разработанное приложение должно реализовывать следующие команды протокола SMTP:

- HELO – передача серверу информации о домене пользователя
- MAIL FROM – передача серверу адреса отправителя письма
- RCPT TO – передача серверу адреса получателя письма
- DATA – передача серверу тела письма
- QUIT – завершение сеанса связи

Настройки приложения. Разработанное приложение должно обеспечивать настройку следующих параметров:

1. Собственное доменное имя для передачи в команде HELO
2. Адрес отправителя
3. IP-адрес или доменное имя сервера SMTP

Методика тестирования. Для тестирования приложения следует использовать почтовые серверы, имеющиеся в лаборатории, а также бесплатные почтовые серверы, имеющиеся в сети Internet 
([http://www.mail.ru] (http://www.mail.ru), [http://www.yandex.ru] (http://www.yandex.ru), [http://www.rambler.ru] (http://www.rambler.ru),  и т.п.).
Средствами разработанного приложения осуществляется передача письма на указанные ящики электронной почты. Штатными клиентами электронной почты проверяется корректность доставки почты и правильность параметров письма.

##Теоритические сведения протокола SMTP 
Предоставленная информация соответсвует [RFC 5321 — Протокол SMTP] (http://rfc2.ru/5321.rfc/print)

###Базовая структура  

Когда у клиента SMTP имеется сообщение для передачи, он организует двухсторонний канал связи с сервером SMTP. Клиент SMTP отвечает за доставку почтовых сообщений одному или множеству серверов SMTP или возврат сообщения об отказе.
После организации коммуникационного канала и согласования параметров клиент SMTP обычно инициирует почтовую транзакцию. Такая транзакция состоит из последовательности команд, задающих отправителя и получателя сообщения, а также передачи содержимого письма (включая все заголовки и прочие структуры).
 Если одно сообщение передается множеству адресатов, разумно передавать одну копию сообщения для всех получателей, доставка которым осуществляется на один хост или через один промежуточный транслятор.
Сервер обеспечивает отклик на каждую полученную команду — отклик может показывать восприятие команды (в таких случаях ожидаются дополнительные команды), а также содержать сообщение о временной или постоянной ошибке. Команды, задающие отправителя или получателей, могут включать поддерживаемые сервером SMTP расширения, описанные ниже. 
Диалог между клиентом и сервером осуществляется поэтапно (команда — отклик — команда ...), хотя можно использовать по взаимному согласию конвейерную обработку.
После завершения передачи сообщения клиент может запросить разрыв соединения или инициировать следующую почтовую транзакцию. Кроме того, клиент SMTP может использовать соединение с сервером для доступа к дополнительному сервису типа проверки корректности почтовых адресов или получения адресов из списка рассылок.

###Обзор процедур SMTP

В этом разделе приведены описания процедур, используемых в SMTP.   

**Инициирование сеанса**

Сеанс SMTP инициируется, когда клиент соединяется с сервером и сервер отвечает соответствующим сообщением.
Реализация сервера SMTP может включать идентификацию своих программ и сведения об их версии в отклик подтверждения соединения после кода 220.
Протокол SMTP позволяет серверу формально отвергать транзакцию, не запрещая изначальные соединения: код 554 может возвращаться в открывающем сообщении взамен кода 220. Сервер, использующий такой вариант, должен по-прежнему ждать, пока клиент передаст команду QUIT перед закрытием соединения, а на любую мешающую команду следует возвращать отклик 503 bad sequence of commands (некорректная последовательность команд). Поскольку попытка организации SMTP-соединения 
с такими системами может приводить к ошибке, серверу, возвращающему код 554, следует передавать вместе с кодом информацию, которая позволит передающей системе понять причину ошибки.

**Инициирование клиента**  

После того, как сервер передал приглашающее сообщение (приветствие) и клиент получил его, последний обычно передает серверу команду EHLO, идентифицирующую клиента. В дополнение к открытию сеанса использование EHLO показывает, что клиент способен работать с расширенным сервисом и запрашивает у сервера список поддерживаемых им расширений. Старые системы SMTP, не способные поддерживать расширения сервиса, и современные клиенты, которым не требуется расширенный сервис в инициируемом почтовом сеансе, могут использовать HELO взамен EHLO.
 Для серверов недопустимо возвращать расширенные отклики в стиле EHLO в ответ на команду HELO. Для конкретной попытки соединения, если сервер возвращает отклик command not recognized (команда не распознана) на команду EHLO, клиенту следует начать процесс заново и передать команду HELO.
Хост, передающий команду EHLO, идентифицирует в ней себя; команду можно интерпретировать как «Hello, I am <domain>» (Привет, я домен ...), а для случая EHLO — «and I support service extension requests» (и я поддерживаю расширения ...).

**Почтовые транзакции**  

Почтовая транзакция SMTP состоит из трех этапов. Началом транзакции служит команда MAIL, дающая идентификацию отправителя. После этого следует одна или несколько команд RCPT, указывающих получателей сообщения. Последний этап транзакции начинается командой DATA, которая инициирует передачу почтовых данных и завершается индикатором end of mail, который также подтверждает транзакцию.

Первым этапом транзакции является команда MAIL.  
MAIL FROM:<reverse-path> [SP <mail-parameters> ] <CRLF>  
Эта команда говорит получателю SMTP о начале новой почтовой транзакции и сбрасывает все таблицы состояний и буферы, включая любые данные получателя или почтовые данные. Часть <reverse-path> (обратный путь) первого или единственного аргумента команды содержит название почтового ящика отправителя (между скобками < и >), которое может использоваться для передачи отчетов об ошибках. Восприняв команду, сервер SMTP возвращает отклик 250 OK.
 Если указанный почтовый ящик по каким-то причинам неприемлем, сервер должен возвратить отклик, показывающий временной тип отказа — постоянная (т. е., повторится при повторе команды клиентом) или временная (т. е., адрес клиента может быть принят при следующем вызове) ошибка.

Вторым этапом транзакции является команда RCPT. Данный этап может повторяться много раз.  
RCPT TO:<forward-path> [ SP <rcpt-parameters> ] <CRLF>   
Первый или единственный аргумент этой команды включает прямой путь forward-path (обычно имя почтового ящика и домена, обязательно заключенные в скобки <>), идентифицирующий получателя. Восприняв команду, сервер SMTP возвращает отклик 250 OK и сохраняет прямой путь. Если известно, что почта не может быть доставлена адресату, сервер SMTP возвращает отклик 550, обычно сопровождаемый строкой типа "no such user - " с именем почтового ящика, для которого невозможна доставка (возможны также другие обстоятельства и коды возврата).

Третьим этапом транзакции является команда DATA (или соответствующая команда протокольного расширения).
DATA <CRLF>
Восприняв команду, сервер SMTP возвращает промежуточный отклик 354 Intermediate и рассматривает все последующие строки, вплоть (но не включая) до индикатора завершения почтовых данных, как текст сообщения. При успешном приеме всего текста сервер сохраняет полученные данные и возвращает отправителю отклик 250 OK.
Протокол SMTP использует для обозначения конца почтовых данных точку в пустой строке.
Индикатор завершения почтовых данных также подтверждает почтовую транзакцию и говорит серверу SMTP, что нужно обрабатывать сохраненные пользовательские и почтовые данные. Восприняв данные, сервер SMTP возвращает отклик 250 OK. Сбой при обработке команды DATA может происходить только на двух этапах обмена данными.
Если команды MAIL и RCPT не были введены или были отвергнуты, сервер может возвращать отклик command out of sequence (503) или no valid recipients (554 — нет корректных получателей) в ответ на команду DATA. При получении одного из таких откликов (или любого отклика 5yz) для клиента недопустима передача данных серверу (точнее, передача данных недопустима, пока не будет получен отклик 354).
Если команда воспринята и передан отклик 354, невыполнение команды DATA может быть связано только с неполнотой почтовой транзакции (например, не указан адресат), недоступностью ресурсов (включая и неожиданнуюнедоступность сервера) или отказом сервера от обработки сообщения в соответствии с заданной политикой или по иным причинам.  
Команды почтовых транзакций должны использоваться в приведенном выше порядке.

###Порядок команд

Сеанс, который будет включать почтовую транзакцию, должен быть сначала инициализирован командой EHLO. Серверам SMTP следует воспринимать без инициализации команды, не использующие почтовых транзакций.
Команда EHLO может вводиться клиентом в действующем сеансе. При первом использовании команды в данной сессии сервер SMTP должен очистить все буферы и сбросить состояние, как при получении команды RSET. 
Если команда EHLO неприемлема для сервера SMTP, он должен возвращать отклик 501, 500, 502 или 550. Сервер SMTP должен сохранять после передачи таких откликов состояние, которое было до получения команды EHLO.
Клиент SMTP должен (по возможности) предоставлять в параметрах команд EHLO первичное доменное имя (не CNAME или MX) своего хоста.  
Команда MAIL начинает почтовую транзакцию. После начала транзакции последняя включает начальную команду, одну или несколько команд RCPT и команду DATA, вводимые в указанном порядке. Почтовая транзакция прерывается командой RSET, новой командой EHLO или командой QUIT.
 В сеансе может происходить множество последовательных транзакций или не быть транзакций вообще. Недопустимо передавать команду MAIL, если почтовая транзакция уже открыта, т. е., эту команду можно передавать только при отсутствии в сеансе продолжающейся почтовой транзакции — предыдущая транзакция должна быть завершена успешным выполнением команды DATA или прервана командой RSET или новой командой EHLO.
Если аргумент начинающей транзакцию команды неприемлем, должен возвращаться отклик 501 и сервер SMTP должен сохранять свое состояние. Если в сеансе нарушается порядок команд в такой степени, что это препятствует их выполнению сервером, последний должен возвратить отклик 503, сохраняя свое состояние.
Последней командой сеанса должна быть команда QUIT. Клиентам следует использовать команду QUIT для разрыва соединения даже в тех случаях, когда команда организации сеанса не была передана и воспринята.

###Расширения протокола

AUTH – аутентификация и шифрование  

AUTH mechanism [initial-response]

Аргументы:  

- mechanism - строка идентифицирующая SASL-механизм аутентификации;
- initial-response - опциональный base64-кодированный ответ.

После успешного выполнения команды AUTH, выполнить её в данном сеансе повторно уже нельзя. 
После успешного завершения команды AUTH, сервер ДОЛЖЕН (MUST) отклонять любые дальнейшие команды AUTH с кодом ответа 503.

Команда AUTH недопустима в процессе выполнения mail-транзакции.

Команда AUTH сообщает серверу механизм аутентификации. Если сервер 
поддерживает запрашиваемый механизм аутентификации, то он выполняет 
аутентификационный протокольный обмен, для того чтобы установить подлинность и идентифицировать пользователя.
 Опционально сервер также договаривается об уровне безопасности. В случае если запрашиваемый механизм аутентификации не поддерживается, сервер отклоняет команду с кодом ответа 504.
Аутентификационный протокольный обмен состоит из серии запросов сервера и ответов клиента зависящих от механизма аутентификации. При получении команды аутентификации от клиента, сервер отправляет клиенту ответ с кодом 334 (ответ о готовности) и текстовой частью содержащей BASE64-закодированную строку. Ответ клиента состоит из BASE64-закодированной строки. Если клиент желает отменить аутентификационный обмен, он должен послать строку с единственным символом "*". Если сервер получает такой ответ, он ДОЛЖЕН отменить команду аутентификации AUTH и выдать ответ с кодом 501.  
В случае если сервер не может декодировать BASE64-аргумент, он отклоняет 
команду AUTH с кодом ответа 501. Если сервер отклоняет утентификационные данные, то ему СЛЕДУЕТ отклонить команду AUTH с кодом ответа 535.
 При успешном завершении клиентом аутентификационного обмена, SMTP сервер отвечает кодом ответа 235.
##Архитектура приложения
###Команды клиента и ответы сервера
 
<table>
  <tr>
    <th>Команда</th>
    <th>Описание</th>
    <th>Положительный ответ сервера</th>
  </tr>
  <tr>
    <td> HELO [домен]</td>
    <td>Передает серверу домен отправителя</td>
    <td>250</td>
  </tr>
  <tr>
    <td>AUTH LOGIN</td>
    <td>Авторизация на сервере. Сервер проверяет, зарегистрирован ли пользователь</td>
    <td>334 – ответ на команду. Далее клиент должен послать закодированный логин.    
        334 – ответ на логин. Далее клиент должен послать закодированный пароль.    
        235 – авторизация пройдена успешно.
    </td>
  </tr>
  <tr>
    <td> MAIL FROM [адрес]</td>
    <td>Передает серверу адрес отправителя</td>
    <td>250</td>
  </tr>
  <tr>
    <td> RCPT TO [адрес]</td>
    <td>Передает серверу адрес получателя</td>
    <td>250</td>
  </tr>
  <tr>
    <td> DATA [текс письма]  </td>
    <td>Передается письмо, со всеми заголовками и полями. Конец письма – точка в пустой строке</td>
    <td>354 – после отправки DATA.   250 – после отправки письма.  </td>
  </tr>
  <tr>
    <td> QUIT</td>
    <td>Разрыв соединения</td>
    <td>221</td>
</table>

Команда DATA имеет собственные заголовки, они добавляются для передачи более полной информации о соообщении. 
К тому же, отсутствие заголовков помогает приемной стороне идентифицироть спам.
В нашей программе добавим следующие заголовки: From, to, Date, Reply-To, Subject, Content-Transfer-Encoding, Content-Type, BCC, CC. Каждое поле заголовка содержит имя, после которого следует двоеточие, а затем следует значение этого поля.
Тело - это содержимое сообщения от отправителя к получателю. RFC 822 определяет тело сообщения как текстовые строки в формате NVT ASCII. Когда происходит передача с использованием команды DATA, заголовки передаются первыми, за ними следует пустая строка и затем следует тело сообщения.     
<table>
  <tr>
    <td>Команда</td>
    <td>Описание</td>
  </tr>
  <tr>
    <td>From: [ ]</td>
    <td>Адрес отправителя</td>
  </tr>
  <tr>
    <td>To: [ ]</td>
    <td>Адрес получателя</td>
  </tr>
  <tr>
    <td>Reply-To: [ ]</td>
    <td>Адрес, на который следует посылать ответ</td>
  </tr> 
  <tr>
    <td>Subject: [ ]</td>
    <td>Тема сообщения</td>
  </tr>
  <tr>
    <td>Content-Transfer-Encoding: base64</td>
    <td>Этот заголовок относится к MIME, стандартному методу помещения в письмо нетекстовой информации. 
    Он не имеет никакого отношения к доставке почты, отвечает только за то, как программа-получатель интерпретирует содержимое сообщения.
    </td>
  </tr>
  <tr>
    <td>Content-Type: text/plain; charset=ISO-8859-1</td>
    <td>Еще один MIME-заголовок, сообщающий почтовой программе о типе данных, хранящихся в сообщении.</td>
  </tr>
  <tr>
    <td>BCC: [ ]</td>
    <td>Имена и адреса получателей письма, чьи адреса не следует показывать другим получателям</td>
  </tr>
    <tr>
    <td>CC: [ ]</td>
    <td>Имена и адреса вторичных получателей письма, к которым направляется копия</td>
  </tr>
  <tr>
    <td>BODY</td>
    <td>Тело письма отделяется от заголовка пустой строкой, а заканчивается строчкой, состоящей из единственной точки (и символа перевода строки)</td>
  </tr>
</table>

В приложении реализованы основные команды SMTP- протокола:

- HELO
- MAIL FROM
- RCPT TO
- DATA   

Возможно использваоние команды EHLO вместо HELO, но  в этом нет необходимсоти.   
Команда AUTH LOGIN используется для аутентификации клиента на сервере. Без этой команды не удалось подключиться к серверу, поэтому было принято решение в её использовании.   
Использование команды DATA без дополнительных заголовков приводит к тому, что сервер отмечает сообщения как спам. Во избежания этого используются дополнительные заголовки, тогда сообщения приходят корректно.
###Классы и методы
**Файл smtp.py.**  
В файле определен класс smtpClient. В классе имеются следующие поля:

- connect - тип boolean, изначально  False. True, если клиент подключился к серверу. 
- auth - тип boolean, изначально  False. True, если клиент аутентифицировался. 
- set - множество получателей письмо, множество формируется из полей пакета RCPT TO, BCC, CC.
- sock - сокет для отправления и према сообщений.  

В классе реализованы функции:

- sendCommandToServer(self,com) - отправление команды на сервер
- encrBase64(self,string) - шифрование алгоритмом base64 при аутентификации
- comConnect(self,string,port) - подключение к серверу
- helo(self,string) - реализация команды HELO
- setAuth(self,login,password) - реализация команды AUTH (аутентификация)
- sendFromTo(self,com,string) - реализация команд MAIL FROM и RCPT TO (указание получателей и отправителя)
- bccCcRcpt(self,string), def sendUsers(self,rcptTo) - разбор строк адресов получателей и BCC, CC адресов. Если адрес корректен, он добавляется в множество set.
- data(self,mailFrom, rcptTo, ccString, bccString, subject, message) - формирование текста сообщения с различными заголовками
- sendData(self,data) - реализация команды DATA 
- sendMessage- отправление текста сообщения
- quit(self) - - реализация команды QUIT (выход)
- rset(self) - сброс текущей команды и обрыв соединения

**Файл view.py.**  
Файл определяет взаимодействие приложения с клиентом через консоль. В нем создается объект класса smtpClient. После чего в бесконечном цикле считывается команда клиента 
и выполняются необходимые операции, если команда корректна. Иначе, выводится сообщение о некорректности команд. Корректные команды:   

- connect- установление соединения   
- quit- разрыв соединения   
- send- отправка сообщения   
- exit-выход из программы 

**Файлы mock_sock.py, test.py**  
Файлы тестируют приложение. Их описание представлено ниже (в подглаве "Тестирование").
###Дизайн приложения

При запуске приложения клиент видит на экране следующее сообщение:  
 
*Введите команду: connect- установление соединения   
quit- разрыв соединения   
send- отправка сообщения   
exit-выход из программы* 
  
При вводе команды connect клиента просят указать название сервера, свой логин и пароль. При удачно выполненных операциях соединение считается установленным. Иначе - не установленным.

При вводе команды send анализируется соединение. Если оно не установлено, клиента оповещают о невозможности отправить сообщение без установления соединения с сервером.
Если соединение установлено клиент поочередно должен ввести ответы на следующие сообщения:   

*Введите адрес отправителя   
Введите адрес получателей через запятую (,)    
Введите bcc адреса через запятую (,)    
Введите cc адреса через запятую (,)   
Введите тему сообщения   
Введите сообщение*  
  
После чего происходит попытка отправить сообщение с указанными параметрами и выводится сообщение об удачной или неудачной попытке отправки сообщения по указанным адресам.

При вводе команды quit также анализируется соединение. Если соединение установлено, оно сбрасывается, и выводится сообщение об удачной операции quit.   
Если соединение не установлено, выводится сообщение о невозможности разрыва неустановленного соединения.

При вводе команды exit  происходит выход из программы.

##Тестирование
За тестирование отвечают файлы mock_sock.py, test.py.   
**Файл mock_sock.py**  
Файл необходим для написания unit тестов. Имеется 2 класса

- MockSocketTrue - класс, переопределеный от класса socket (пакета socket). Переопределяет операции connect, send, recv.   
Всегда возвращает верные коды ответов сервера в зависимости от отправляемой команды. Таким образом, можно проверить работу методов при верных ответах от сервера.
- MockSocketFalse - класс, переопределеный от класса socket (пакета socket). Переопределяет операции connect, send, recv.   
Всегда возвращает код ответа 500, что является ошибочным кодом. Таким образом, можно проверить работу методов при ошибочных кодах ответа сервера.   

**Файл test.py**  
Файл имеет несколько классов, классы ориентированы на проверку определенных команд.

*Unit тесты.*  Создается объект класса MockSocketTrue(MockSocketFalse) и проверяется работа объекта SmtpClient
при верных(или неверных) кодах ответа сервера. При этом не происходит непосредственное подключение к серверу, переопределенные сокеты являются оболочкой.   
Классы:

- TestMockSocketFalse 
- TestMockSocketTrue

*Интеграционные тесты.*  Создаются объекты классов socket (пакета socket) и SmtpClient.
Происходит непосредственное подключение к серверу, после чего, задавая определенные параметры входных значений, проверяется работа отдельных методов класса SmtpClient.  
Классы:

- TestSmtpConnect - тестирует команды установления соединения (методы connect, helo)
- TestAuth - тестирует команды аутентификации и выхода (методы setAuth, quit)
- TestSend - тестирует команды установления адресов отправителя и получателей, отправления сообщения и сброс текущей команды с разрывом соединения (методы sendFromTo, sendMessage, rset)    

С помощью бибилиотеки coverage было проанализировано тестовое покрытие. Анализируются только файлы, содержащие тестируемые и вспомогательные функции - test.py и mock_sock.py.
Общее тестовое покрытие составляет 98% (почти 100%), это говорит о прохождении почти всех строк приложения, а значит проверке различных возникающих ситуаций.    
Файл view.py отвечает за взаимодейтсвие приложения с клиентом, он не содежит отдельных методов, которые можно было бы проверить с помощью интеграционных методов.
Поэтому для решения этой задачи использовалось ручное тестирование, с его помощью была проверена не только функциональность методов, но и их взаимодействие между собой.   